package db

import (
	"encoding/json"

	"github.com/aquasecurity/trivy-db/pkg/types"

	bolt "go.etcd.io/bbolt"
	"golang.org/x/xerrors"
)

const (
	vulnerabilityExploitableBucket = "vulnerability-exploitable"
)

func (dbc Config) PutVulnerabilityExploitable(tx *bolt.Tx, cveID string, source types.SourceID, exploitable types.VulnerabilityExploitable) error {
	if err := dbc.put(tx, []string{vulnerabilityExploitableBucket, cveID}, string(source), exploitable); err != nil {
		return xerrors.Errorf("failed to put vulnerability exploitable: %w", err)
	}
	return nil
}

func (dbc Config) GetVulnerabilityExploitable(cveID string) (map[types.SourceID]types.VulnerabilityExploitable, error) {
	values, err := dbc.forEach([]string{vulnerabilityExploitableBucket, cveID})
	if err != nil {
		return nil, xerrors.Errorf("error in Exploitable bucket get: %w", err)
	}
	if len(values) == 0 {
		return nil, nil
	}

	exploitables := map[types.SourceID]types.VulnerabilityExploitable{}

	for source, value := range values {
		var exploitable types.VulnerabilityExploitable
		if err = json.Unmarshal(value.Content, &exploitable); err != nil {
			return nil, xerrors.Errorf("failed to unmarshal Vulnerability Exploitable JSON: %w", err)
		}
		exploitables[types.SourceID(source)] = exploitable
	}
	return exploitables, nil
}

func (dbc Config) DeleteVulnerabilityExploitableBucket() error {
	return dbc.deleteBucket(vulnerabilityExploitableBucket)
}
