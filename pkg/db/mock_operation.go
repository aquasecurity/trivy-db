// Code generated by mockery v1.0.0. DO NOT EDIT.

package db

import (
	types "github.com/aquasecurity/trivy-db/pkg/types"
	mock "github.com/stretchr/testify/mock"
	bbolt "go.etcd.io/bbolt"
)

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

type OperationBatchUpdateArgs struct {
	Fn         func(*bbolt.Tx) error
	FnAnything bool
}

type OperationBatchUpdateReturns struct {
	Err error
}

type OperationBatchUpdateExpectation struct {
	Args    OperationBatchUpdateArgs
	Returns OperationBatchUpdateReturns
}

func (_m *MockOperation) ApplyBatchUpdateExpectation(e OperationBatchUpdateExpectation) {
	var args []interface{}
	if e.Args.FnAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Fn)
	}
	_m.On("BatchUpdate", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyBatchUpdateExpectations(expectations []OperationBatchUpdateExpectation) {
	for _, e := range expectations {
		_m.ApplyBatchUpdateExpectation(e)
	}
}

// BatchUpdate provides a mock function with given fields: fn
func (_m *MockOperation) BatchUpdate(fn func(*bbolt.Tx) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationDeleteAdvisoryDetailBucketReturns struct {
	_a0 error
}

type OperationDeleteAdvisoryDetailBucketExpectation struct {
	Returns OperationDeleteAdvisoryDetailBucketReturns
}

func (_m *MockOperation) ApplyDeleteAdvisoryDetailBucketExpectation(e OperationDeleteAdvisoryDetailBucketExpectation) {
	var args []interface{}
	_m.On("DeleteAdvisoryDetailBucket", args...).Return(e.Returns._a0)
}

func (_m *MockOperation) ApplyDeleteAdvisoryDetailBucketExpectations(expectations []OperationDeleteAdvisoryDetailBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteAdvisoryDetailBucketExpectation(e)
	}
}

// DeleteAdvisoryDetailBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteAdvisoryDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationDeleteSeverityBucketReturns struct {
	Err error
}

type OperationDeleteSeverityBucketExpectation struct {
	Returns OperationDeleteSeverityBucketReturns
}

func (_m *MockOperation) ApplyDeleteSeverityBucketExpectation(e OperationDeleteSeverityBucketExpectation) {
	var args []interface{}
	_m.On("DeleteSeverityBucket", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDeleteSeverityBucketExpectations(expectations []OperationDeleteSeverityBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteSeverityBucketExpectation(e)
	}
}

// DeleteSeverityBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteSeverityBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationDeleteVulnerabilityDetailBucketReturns struct {
	Err error
}

type OperationDeleteVulnerabilityDetailBucketExpectation struct {
	Returns OperationDeleteVulnerabilityDetailBucketReturns
}

func (_m *MockOperation) ApplyDeleteVulnerabilityDetailBucketExpectation(e OperationDeleteVulnerabilityDetailBucketExpectation) {
	var args []interface{}
	_m.On("DeleteVulnerabilityDetailBucket", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDeleteVulnerabilityDetailBucketExpectations(expectations []OperationDeleteVulnerabilityDetailBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteVulnerabilityDetailBucketExpectation(e)
	}
}

// DeleteVulnerabilityDetailBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteVulnerabilityDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationForEachAdvisoryArgs struct {
	Source          string
	SourceAnything  bool
	PkgName         string
	PkgNameAnything bool
}

type OperationForEachAdvisoryReturns struct {
	Value map[string][]byte
	Err   error
}

type OperationForEachAdvisoryExpectation struct {
	Args    OperationForEachAdvisoryArgs
	Returns OperationForEachAdvisoryReturns
}

func (_m *MockOperation) ApplyForEachAdvisoryExpectation(e OperationForEachAdvisoryExpectation) {
	var args []interface{}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	_m.On("ForEachAdvisory", args...).Return(e.Returns.Value, e.Returns.Err)
}

func (_m *MockOperation) ApplyForEachAdvisoryExpectations(expectations []OperationForEachAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachAdvisoryExpectation(e)
	}
}

// ForEachAdvisory provides a mock function with given fields: source, pkgName
func (_m *MockOperation) ForEachAdvisory(source string, pkgName string) (map[string][]byte, error) {
	ret := _m.Called(source, pkgName)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(string, string) map[string][]byte); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationForEachSeverityArgs struct {
	Fn         func(*bbolt.Tx, string, types.Severity) error
	FnAnything bool
}

type OperationForEachSeverityReturns struct {
	Err error
}

type OperationForEachSeverityExpectation struct {
	Args    OperationForEachSeverityArgs
	Returns OperationForEachSeverityReturns
}

func (_m *MockOperation) ApplyForEachSeverityExpectation(e OperationForEachSeverityExpectation) {
	var args []interface{}
	if e.Args.FnAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Fn)
	}
	_m.On("ForEachSeverity", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyForEachSeverityExpectations(expectations []OperationForEachSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachSeverityExpectation(e)
	}
}

// ForEachSeverity provides a mock function with given fields: fn
func (_m *MockOperation) ForEachSeverity(fn func(*bbolt.Tx, string, types.Severity) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx, string, types.Severity) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationGetAdvisoriesArgs struct {
	Source          string
	SourceAnything  bool
	PkgName         string
	PkgNameAnything bool
}

type OperationGetAdvisoriesReturns struct {
	Advisories []types.Advisory
	Err        error
}

type OperationGetAdvisoriesExpectation struct {
	Args    OperationGetAdvisoriesArgs
	Returns OperationGetAdvisoriesReturns
}

func (_m *MockOperation) ApplyGetAdvisoriesExpectation(e OperationGetAdvisoriesExpectation) {
	var args []interface{}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	_m.On("GetAdvisories", args...).Return(e.Returns.Advisories, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetAdvisoriesExpectations(expectations []OperationGetAdvisoriesExpectation) {
	for _, e := range expectations {
		_m.ApplyGetAdvisoriesExpectation(e)
	}
}

// GetAdvisories provides a mock function with given fields: source, pkgName
func (_m *MockOperation) GetAdvisories(source string, pkgName string) ([]types.Advisory, error) {
	ret := _m.Called(source, pkgName)

	var r0 []types.Advisory
	if rf, ok := ret.Get(0).(func(string, string) []types.Advisory); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Advisory)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetAdvisoryDetailsArgs struct {
	CveID         string
	CveIDAnything bool
}

type OperationGetAdvisoryDetailsReturns struct {
	Details []types.AdvisoryDetail
	Err     error
}

type OperationGetAdvisoryDetailsExpectation struct {
	Args    OperationGetAdvisoryDetailsArgs
	Returns OperationGetAdvisoryDetailsReturns
}

func (_m *MockOperation) ApplyGetAdvisoryDetailsExpectation(e OperationGetAdvisoryDetailsExpectation) {
	var args []interface{}
	if e.Args.CveIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.CveID)
	}
	_m.On("GetAdvisoryDetails", args...).Return(e.Returns.Details, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetAdvisoryDetailsExpectations(expectations []OperationGetAdvisoryDetailsExpectation) {
	for _, e := range expectations {
		_m.ApplyGetAdvisoryDetailsExpectation(e)
	}
}

// GetAdvisoryDetails provides a mock function with given fields: cveID
func (_m *MockOperation) GetAdvisoryDetails(cveID string) ([]types.AdvisoryDetail, error) {
	ret := _m.Called(cveID)

	var r0 []types.AdvisoryDetail
	if rf, ok := ret.Get(0).(func(string) []types.AdvisoryDetail); ok {
		r0 = rf(cveID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.AdvisoryDetail)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(cveID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetSeverityArgs struct {
	VulnerabilityID         string
	VulnerabilityIDAnything bool
}

type OperationGetSeverityReturns struct {
	Severity types.Severity
	Err      error
}

type OperationGetSeverityExpectation struct {
	Args    OperationGetSeverityArgs
	Returns OperationGetSeverityReturns
}

func (_m *MockOperation) ApplyGetSeverityExpectation(e OperationGetSeverityExpectation) {
	var args []interface{}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	_m.On("GetSeverity", args...).Return(e.Returns.Severity, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetSeverityExpectations(expectations []OperationGetSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetSeverityExpectation(e)
	}
}

// GetSeverity provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetSeverity(vulnerabilityID string) (types.Severity, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Severity
	if rf, ok := ret.Get(0).(func(string) types.Severity); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Severity)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetVulnerabilityArgs struct {
	VulnerabilityID         string
	VulnerabilityIDAnything bool
}

type OperationGetVulnerabilityReturns struct {
	Vulnerability types.Vulnerability
	Err           error
}

type OperationGetVulnerabilityExpectation struct {
	Args    OperationGetVulnerabilityArgs
	Returns OperationGetVulnerabilityReturns
}

func (_m *MockOperation) ApplyGetVulnerabilityExpectation(e OperationGetVulnerabilityExpectation) {
	var args []interface{}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	_m.On("GetVulnerability", args...).Return(e.Returns.Vulnerability, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetVulnerabilityExpectations(expectations []OperationGetVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetVulnerabilityExpectation(e)
	}
}

// GetVulnerability provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetVulnerability(vulnerabilityID string) (types.Vulnerability, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Vulnerability
	if rf, ok := ret.Get(0).(func(string) types.Vulnerability); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Vulnerability)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetVulnerabilityDetailArgs struct {
	CveID         string
	CveIDAnything bool
}

type OperationGetVulnerabilityDetailReturns struct {
	Detail map[string]types.VulnerabilityDetail
	Err    error
}

type OperationGetVulnerabilityDetailExpectation struct {
	Args    OperationGetVulnerabilityDetailArgs
	Returns OperationGetVulnerabilityDetailReturns
}

func (_m *MockOperation) ApplyGetVulnerabilityDetailExpectation(e OperationGetVulnerabilityDetailExpectation) {
	var args []interface{}
	if e.Args.CveIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.CveID)
	}
	_m.On("GetVulnerabilityDetail", args...).Return(e.Returns.Detail, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetVulnerabilityDetailExpectations(expectations []OperationGetVulnerabilityDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyGetVulnerabilityDetailExpectation(e)
	}
}

// GetVulnerabilityDetail provides a mock function with given fields: cveID
func (_m *MockOperation) GetVulnerabilityDetail(cveID string) (map[string]types.VulnerabilityDetail, error) {
	ret := _m.Called(cveID)

	var r0 map[string]types.VulnerabilityDetail
	if rf, ok := ret.Get(0).(func(string) map[string]types.VulnerabilityDetail); ok {
		r0 = rf(cveID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.VulnerabilityDetail)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(cveID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationPutAdvisoryArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	Source                  string
	SourceAnything          bool
	PkgName                 string
	PkgNameAnything         bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Advisory                interface{}
	AdvisoryAnything        bool
}

type OperationPutAdvisoryReturns struct {
	Err error
}

type OperationPutAdvisoryExpectation struct {
	Args    OperationPutAdvisoryArgs
	Returns OperationPutAdvisoryReturns
}

func (_m *MockOperation) ApplyPutAdvisoryExpectation(e OperationPutAdvisoryExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.AdvisoryAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Advisory)
	}
	_m.On("PutAdvisory", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutAdvisoryExpectations(expectations []OperationPutAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyPutAdvisoryExpectation(e)
	}
}

// PutAdvisory provides a mock function with given fields: tx, source, pkgName, vulnerabilityID, advisory
func (_m *MockOperation) PutAdvisory(tx *bbolt.Tx, source string, pkgName string, vulnerabilityID string, advisory interface{}) error {
	ret := _m.Called(tx, source, pkgName, vulnerabilityID, advisory)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, string, interface{}) error); ok {
		r0 = rf(tx, source, pkgName, vulnerabilityID, advisory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutAdvisoryDetailArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Source                  string
	SourceAnything          bool
	PkgName                 string
	PkgNameAnything         bool
	Advisory                interface{}
	AdvisoryAnything        bool
}

type OperationPutAdvisoryDetailReturns struct {
	Err error
}

type OperationPutAdvisoryDetailExpectation struct {
	Args    OperationPutAdvisoryDetailArgs
	Returns OperationPutAdvisoryDetailReturns
}

func (_m *MockOperation) ApplyPutAdvisoryDetailExpectation(e OperationPutAdvisoryDetailExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	if e.Args.AdvisoryAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Advisory)
	}
	_m.On("PutAdvisoryDetail", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutAdvisoryDetailExpectations(expectations []OperationPutAdvisoryDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyPutAdvisoryDetailExpectation(e)
	}
}

// PutAdvisoryDetail provides a mock function with given fields: tx, vulnerabilityID, source, pkgName, advisory
func (_m *MockOperation) PutAdvisoryDetail(tx *bbolt.Tx, vulnerabilityID string, source string, pkgName string, advisory interface{}) error {
	ret := _m.Called(tx, vulnerabilityID, source, pkgName, advisory)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, string, interface{}) error); ok {
		r0 = rf(tx, vulnerabilityID, source, pkgName, advisory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutSeverityArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Severity                types.Severity
	SeverityAnything        bool
}

type OperationPutSeverityReturns struct {
	Err error
}

type OperationPutSeverityExpectation struct {
	Args    OperationPutSeverityArgs
	Returns OperationPutSeverityReturns
}

func (_m *MockOperation) ApplyPutSeverityExpectation(e OperationPutSeverityExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SeverityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Severity)
	}
	_m.On("PutSeverity", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutSeverityExpectations(expectations []OperationPutSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutSeverityExpectation(e)
	}
}

// PutSeverity provides a mock function with given fields: tx, vulnerabilityID, severity
func (_m *MockOperation) PutSeverity(tx *bbolt.Tx, vulnerabilityID string, severity types.Severity) error {
	ret := _m.Called(tx, vulnerabilityID, severity)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Severity) error); ok {
		r0 = rf(tx, vulnerabilityID, severity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutVulnerabilityArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Vulnerability           types.Vulnerability
	VulnerabilityAnything   bool
}

type OperationPutVulnerabilityReturns struct {
	Err error
}

type OperationPutVulnerabilityExpectation struct {
	Args    OperationPutVulnerabilityArgs
	Returns OperationPutVulnerabilityReturns
}

func (_m *MockOperation) ApplyPutVulnerabilityExpectation(e OperationPutVulnerabilityExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.VulnerabilityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulnerability)
	}
	_m.On("PutVulnerability", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutVulnerabilityExpectations(expectations []OperationPutVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityExpectation(e)
	}
}

// PutVulnerability provides a mock function with given fields: tx, vulnerabilityID, vulnerability
func (_m *MockOperation) PutVulnerability(tx *bbolt.Tx, vulnerabilityID string, vulnerability types.Vulnerability) error {
	ret := _m.Called(tx, vulnerabilityID, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Vulnerability) error); ok {
		r0 = rf(tx, vulnerabilityID, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutVulnerabilityDetailArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Source                  string
	SourceAnything          bool
	Vulnerability           types.VulnerabilityDetail
	VulnerabilityAnything   bool
}

type OperationPutVulnerabilityDetailReturns struct {
	Err error
}

type OperationPutVulnerabilityDetailExpectation struct {
	Args    OperationPutVulnerabilityDetailArgs
	Returns OperationPutVulnerabilityDetailReturns
}

func (_m *MockOperation) ApplyPutVulnerabilityDetailExpectation(e OperationPutVulnerabilityDetailExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.VulnerabilityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulnerability)
	}
	_m.On("PutVulnerabilityDetail", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutVulnerabilityDetailExpectations(expectations []OperationPutVulnerabilityDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityDetailExpectation(e)
	}
}

// PutVulnerabilityDetail provides a mock function with given fields: tx, vulnerabilityID, source, vulnerability
func (_m *MockOperation) PutVulnerabilityDetail(tx *bbolt.Tx, vulnerabilityID string, source string, vulnerability types.VulnerabilityDetail) error {
	ret := _m.Called(tx, vulnerabilityID, source, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, types.VulnerabilityDetail) error); ok {
		r0 = rf(tx, vulnerabilityID, source, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
