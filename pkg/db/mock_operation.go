// Code generated by mockery v1.0.0. DO NOT EDIT.

package db

import (
	types "github.com/aquasecurity/trivy-db/pkg/types"
	mock "github.com/stretchr/testify/mock"
	bbolt "go.etcd.io/bbolt"
)

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

type BatchUpdateArgs struct {
	Fn         func(*bbolt.Tx) error
	FnAnything bool
}

type BatchUpdateReturns struct {
	Err error
}

type BatchUpdateExpectation struct {
	Args    BatchUpdateArgs
	Returns BatchUpdateReturns
}

func (_m *MockOperation) ApplyBatchUpdateExpectation(e BatchUpdateExpectation) {
	var args []interface{}
	if e.Args.FnAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Fn)
	}
	_m.On("BatchUpdate", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyBatchUpdateExpectations(expectations []BatchUpdateExpectation) {
	for _, e := range expectations {
		_m.ApplyBatchUpdateExpectation(e)
	}
}

// BatchUpdate provides a mock function with given fields: fn
func (_m *MockOperation) BatchUpdate(fn func(*bbolt.Tx) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type DeleteSeverityBucketReturns struct {
	Err error
}

type DeleteSeverityBucketExpectation struct {
	Returns DeleteSeverityBucketReturns
}

func (_m *MockOperation) ApplyDeleteSeverityBucketExpectation(e DeleteSeverityBucketExpectation) {
	var args []interface{}
	_m.On("DeleteSeverityBucket", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDeleteSeverityBucketExpectations(expectations []DeleteSeverityBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteSeverityBucketExpectation(e)
	}
}

// DeleteSeverityBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteSeverityBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type DeleteVulnerabilityDetailBucketReturns struct {
	Err error
}

type DeleteVulnerabilityDetailBucketExpectation struct {
	Returns DeleteVulnerabilityDetailBucketReturns
}

func (_m *MockOperation) ApplyDeleteVulnerabilityDetailBucketExpectation(e DeleteVulnerabilityDetailBucketExpectation) {
	var args []interface{}
	_m.On("DeleteVulnerabilityDetailBucket", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDeleteVulnerabilityDetailBucketExpectations(expectations []DeleteVulnerabilityDetailBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteVulnerabilityDetailBucketExpectation(e)
	}
}

// DeleteVulnerabilityDetailBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteVulnerabilityDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type ForEachAdvisoryArgs struct {
	Source          string
	SourceAnything  bool
	PkgName         string
	PkgNameAnything bool
}

type ForEachAdvisoryReturns struct {
	Value map[string][]byte
	Err   error
}

type ForEachAdvisoryExpectation struct {
	Args    ForEachAdvisoryArgs
	Returns ForEachAdvisoryReturns
}

func (_m *MockOperation) ApplyForEachAdvisoryExpectation(e ForEachAdvisoryExpectation) {
	var args []interface{}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	_m.On("ForEachAdvisory", args...).Return(e.Returns.Value, e.Returns.Err)
}

func (_m *MockOperation) ApplyForEachAdvisoryExpectations(expectations []ForEachAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachAdvisoryExpectation(e)
	}
}

// ForEachAdvisory provides a mock function with given fields: source, pkgName
func (_m *MockOperation) ForEachAdvisory(source string, pkgName string) (map[string][]byte, error) {
	ret := _m.Called(source, pkgName)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(string, string) map[string][]byte); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ForEachSeverityArgs struct {
	Fn         func(*bbolt.Tx, string, types.Severity) error
	FnAnything bool
}

type ForEachSeverityReturns struct {
	Err error
}

type ForEachSeverityExpectation struct {
	Args    ForEachSeverityArgs
	Returns ForEachSeverityReturns
}

func (_m *MockOperation) ApplyForEachSeverityExpectation(e ForEachSeverityExpectation) {
	var args []interface{}
	if e.Args.FnAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Fn)
	}
	_m.On("ForEachSeverity", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyForEachSeverityExpectations(expectations []ForEachSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachSeverityExpectation(e)
	}
}

// ForEachSeverity provides a mock function with given fields: fn
func (_m *MockOperation) ForEachSeverity(fn func(*bbolt.Tx, string, types.Severity) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx, string, types.Severity) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type GetAdvisoriesArgs struct {
	Source          string
	SourceAnything  bool
	PkgName         string
	PkgNameAnything bool
}

type GetAdvisoriesReturns struct {
	Advisories []types.Advisory
	Err        error
}

type GetAdvisoriesExpectation struct {
	Args    GetAdvisoriesArgs
	Returns GetAdvisoriesReturns
}

func (_m *MockOperation) ApplyGetAdvisoriesExpectation(e GetAdvisoriesExpectation) {
	var args []interface{}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	_m.On("GetAdvisories", args...).Return(e.Returns.Advisories, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetAdvisoriesExpectations(expectations []GetAdvisoriesExpectation) {
	for _, e := range expectations {
		_m.ApplyGetAdvisoriesExpectation(e)
	}
}

// GetAdvisories provides a mock function with given fields: source, pkgName
func (_m *MockOperation) GetAdvisories(source string, pkgName string) ([]types.Advisory, error) {
	ret := _m.Called(source, pkgName)

	var r0 []types.Advisory
	if rf, ok := ret.Get(0).(func(string, string) []types.Advisory); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Advisory)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type GetSeverityArgs struct {
	VulnerabilityID         string
	VulnerabilityIDAnything bool
}

type GetSeverityReturns struct {
	Severity types.Severity
	Err      error
}

type GetSeverityExpectation struct {
	Args    GetSeverityArgs
	Returns GetSeverityReturns
}

func (_m *MockOperation) ApplyGetSeverityExpectation(e GetSeverityExpectation) {
	var args []interface{}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	_m.On("GetSeverity", args...).Return(e.Returns.Severity, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetSeverityExpectations(expectations []GetSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetSeverityExpectation(e)
	}
}

// GetSeverity provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetSeverity(vulnerabilityID string) (types.Severity, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Severity
	if rf, ok := ret.Get(0).(func(string) types.Severity); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Severity)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type GetVulnerabilityArgs struct {
	VulnerabilityID         string
	VulnerabilityIDAnything bool
}

type GetVulnerabilityReturns struct {
	Vulnerability types.Vulnerability
	Err           error
}

type GetVulnerabilityExpectation struct {
	Args    GetVulnerabilityArgs
	Returns GetVulnerabilityReturns
}

func (_m *MockOperation) ApplyGetVulnerabilityExpectation(e GetVulnerabilityExpectation) {
	var args []interface{}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	_m.On("GetVulnerability", args...).Return(e.Returns.Vulnerability, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetVulnerabilityExpectations(expectations []GetVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetVulnerabilityExpectation(e)
	}
}

// GetVulnerability provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetVulnerability(vulnerabilityID string) (types.Vulnerability, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Vulnerability
	if rf, ok := ret.Get(0).(func(string) types.Vulnerability); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Vulnerability)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type PutAdvisoryArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	Source                  string
	SourceAnything          bool
	PkgName                 string
	PkgNameAnything         bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Advisory                interface{}
	AdvisoryAnything        bool
}

type PutAdvisoryReturns struct {
	Err error
}

type PutAdvisoryExpectation struct {
	Args    PutAdvisoryArgs
	Returns PutAdvisoryReturns
}

func (_m *MockOperation) ApplyPutAdvisoryExpectation(e PutAdvisoryExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.AdvisoryAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Advisory)
	}
	_m.On("PutAdvisory", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutAdvisoryExpectations(expectations []PutAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyPutAdvisoryExpectation(e)
	}
}

// PutAdvisory provides a mock function with given fields: tx, source, pkgName, vulnerabilityID, advisory
func (_m *MockOperation) PutAdvisory(tx *bbolt.Tx, source string, pkgName string, vulnerabilityID string, advisory interface{}) error {
	ret := _m.Called(tx, source, pkgName, vulnerabilityID, advisory)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, string, interface{}) error); ok {
		r0 = rf(tx, source, pkgName, vulnerabilityID, advisory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type PutSeverityArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Severity                types.Severity
	SeverityAnything        bool
}

type PutSeverityReturns struct {
	Err error
}

type PutSeverityExpectation struct {
	Args    PutSeverityArgs
	Returns PutSeverityReturns
}

func (_m *MockOperation) ApplyPutSeverityExpectation(e PutSeverityExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SeverityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Severity)
	}
	_m.On("PutSeverity", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutSeverityExpectations(expectations []PutSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutSeverityExpectation(e)
	}
}

// PutSeverity provides a mock function with given fields: tx, vulnerabilityID, severity
func (_m *MockOperation) PutSeverity(tx *bbolt.Tx, vulnerabilityID string, severity types.Severity) error {
	ret := _m.Called(tx, vulnerabilityID, severity)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Severity) error); ok {
		r0 = rf(tx, vulnerabilityID, severity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type PutVulnerabilityArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Vulnerability           types.Vulnerability
	VulnerabilityAnything   bool
}

type PutVulnerabilityReturns struct {
	Err error
}

type PutVulnerabilityExpectation struct {
	Args    PutVulnerabilityArgs
	Returns PutVulnerabilityReturns
}

func (_m *MockOperation) ApplyPutVulnerabilityExpectation(e PutVulnerabilityExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.VulnerabilityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulnerability)
	}
	_m.On("PutVulnerability", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutVulnerabilityExpectations(expectations []PutVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityExpectation(e)
	}
}

// PutVulnerability provides a mock function with given fields: tx, vulnerabilityID, vulnerability
func (_m *MockOperation) PutVulnerability(tx *bbolt.Tx, vulnerabilityID string, vulnerability types.Vulnerability) error {
	ret := _m.Called(tx, vulnerabilityID, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Vulnerability) error); ok {
		r0 = rf(tx, vulnerabilityID, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type PutVulnerabilityDetailArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Source                  string
	SourceAnything          bool
	Vulnerability           types.VulnerabilityDetail
	VulnerabilityAnything   bool
}

type PutVulnerabilityDetailReturns struct {
	Err error
}

type PutVulnerabilityDetailExpectation struct {
	Args    PutVulnerabilityDetailArgs
	Returns PutVulnerabilityDetailReturns
}

func (_m *MockOperation) ApplyPutVulnerabilityDetailExpectation(e PutVulnerabilityDetailExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.VulnerabilityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulnerability)
	}
	_m.On("PutVulnerabilityDetail", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutVulnerabilityDetailExpectations(expectations []PutVulnerabilityDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityDetailExpectation(e)
	}
}

// PutVulnerabilityDetail provides a mock function with given fields: tx, vulnerabilityID, source, vulnerability
func (_m *MockOperation) PutVulnerabilityDetail(tx *bbolt.Tx, vulnerabilityID string, source string, vulnerability types.VulnerabilityDetail) error {
	ret := _m.Called(tx, vulnerabilityID, source, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, types.VulnerabilityDetail) error); ok {
		r0 = rf(tx, vulnerabilityID, source, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
