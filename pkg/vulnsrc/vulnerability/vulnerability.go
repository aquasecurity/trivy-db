package vulnerability

import (
	"log"
	"sort"
	"strings"

	"github.com/aquasecurity/trivy-db/pkg/types"

	"github.com/aquasecurity/trivy-db/pkg/db"
)

var (
	sources = []string{Nvd, RedHat, Debian, DebianOVAL, Alpine, Amazon,
		RubySec, RustSec, PhpSecurityAdvisories, NodejsSecurityWg, PythonSafetyDB}
)

func GetDetail(vulnID string) (types.Severity, string, string, []string) {
	details, err := db.Config{}.GetVulnerabilityDetail(vulnID)
	if err != nil {
		log.Println(err)
		return types.SeverityUnknown, "", "", nil
	} else if len(details) == 0 {
		return types.SeverityUnknown, "", "", nil
	}
	return getSeverity(details), getTitle(details), getDescription(details), getReferences(details)
}

func getSeverity(details map[string]types.VulnerabilityDetail) types.Severity {
	for _, source := range sources {
		switch d, ok := details[source]; {
		case !ok:
			continue
		case d.CvssScore > 0:
			return scoreToSeverity(d.CvssScore)
		case d.CvssScoreV3 > 0:
			return scoreToSeverity(d.CvssScoreV3)
		case d.Severity != 0:
			return d.Severity
		case d.SeverityV3 != 0:
			return d.SeverityV3
		}
	}
	return types.SeverityUnknown
}

func getTitle(details map[string]types.VulnerabilityDetail) string {
	for _, source := range sources {
		d, ok := details[source]
		if !ok {
			continue
		}
		if d.Title != "" {
			return d.Title
		}
	}
	return ""
}

func getDescription(details map[string]types.VulnerabilityDetail) string {
	for _, source := range sources {
		d, ok := details[source]
		if !ok {
			continue
		}
		if d.Description != "" {
			return d.Description
		}
	}
	return ""
}

func getReferences(details map[string]types.VulnerabilityDetail) []string {
	references := map[string]struct{}{}
	for _, source := range sources {
		// Amazon contains unrelated references
		if source == Amazon {
			continue
		}
		d, ok := details[source]
		if !ok {
			continue
		}
		for _, ref := range d.References {
			// e.g. "\nhttps://curl.haxx.se/docs/CVE-2019-5481.html\n    "
			ref = strings.TrimSpace(ref)
			for _, r := range strings.Split(ref, "\n") {
				references[r] = struct{}{}
			}
		}
	}
	var refs []string
	for ref := range references {
		refs = append(refs, ref)
	}
	sort.Slice(refs, func(i, j int) bool {
		return refs[i] < refs[j]
	})
	return refs
}

func scoreToSeverity(score float64) types.Severity {
	switch {
	case score >= 9.0:
		return types.SeverityCritical
	case score >= 7.0:
		return types.SeverityHigh
	case score >= 4.0:
		return types.SeverityMedium
	case score > 0.0:
		return types.SeverityLow
	default:
		return types.SeverityUnknown
	}
}
